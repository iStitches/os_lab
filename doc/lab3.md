# 高级操作系统实验三报告

## 一、 实验平台

实验所用的软硬件平台如表1所示。

表-1 实验所用的软硬件平台

| CPU型号  | 11th Gen  Intel(R) Core(TM) i7-11800H |
| -------- | ------------------------------------- |
| 微结构   | X86_64                                |
| 主频     | 2.30GHz                               |
| 核数     | 1                                     |
| 操作系统 | Centos 7                              |
| 编译器   | gcc 7.5.0                             |

## 二、 实验内容

### 1.  问题描述

* 掌握套接字函数的使用；

* 掌握线程间通信与同步方法；

* 应用套接字函数完成多线程实验；

实验要求实现基于网络的文件传输工具，服务器指定目录（不要求子目录）文件，当请求到来时创建线程处理当前请求任务。服务器命令包括指定服务器地址（--listen=ADDR）、指定服务端套接字端口（--port=PORT）、展示隐藏文件（--hiden）、展示帮助信息（--help）。

客户端命令包括展示远程服务器文件列表（--list）、指定客户端地址（--server）、指定服务端套接字端口（--port）、展示帮助信息（--help）、下载文件（-dl=FILE）、文件输出（-ouput=FILE）。

### 2.  实验要求

* 使用（C/C++/Rust）中任意两种语言完成本实验，并分析两种实现方案的差异（可从代码，二进制大小，执行效率等方面分析）。

* C/C++ 使用CMake或Makefile构建，Rust使用Cargo构建。

* 实验报告用markdown文件编写，放置于仓库的doc目录下。

### 3. 实验方法

客户端上的进程和服务端上的进程通过网络套接字进行进程间通信。传输层采用TCP协议，保证在成功建立连接的情况下再进行数据交互。建立TCP连接的主要步骤如下：

**Server端（先运行）：**

​	1.取得 SOCKET (socket) IPPROTO_SCTP 是一种新协议，也可以实现流式套接字；

​    2.给 SOCKET 取得地址 (bind)；

​    3.将 SOCKET 置为监听模式 (listen) backlog 参数写什么正整数都行；

​    4.接受链接 (accept) 如果成功返回接受链接的文件描述符，失败返回 -1 并设置 errno。注意不能直接用存放之前 socket 返回的文件描述符变量来接收 accept 的返回值，因为accept可能会遇到假错，这样之前变量里保存的文件描述符就丢了，会导致内存泄漏；

​    5.收/发消息 (send)；

​    6.关闭 SOCKET (close)；

​    

 **Client端（后运行）：**

​	1.取得 SOCKET (socket)；

​    2.给SOCKET 取得地址（可省）(bind)；

​    3.发起链接 (connect)；

​    4.收/发消息；

​    5.关闭SOCKET；

​    

![在这里插入图片描述](https://img-blog.csdnimg.cn/8f8229c636154d4b8fb874c8c7c02cb8.png)

​    展示服务器目录下的文件列表的功能实现，可以采用 system(xxx) 系统调用去执行shell命令，并将结果写入 temp 临时文件，然后读取文件内容返回给客户端，以此获取目录下的文件列表。

​    下载服务器目录下的指定文件功能实现，客户端在成功连接服务器后获取到网络连接的文件描述符fd1，然后通过write写入待下载文件名称传输到服务端。服务器accept() 阻塞接收到客户端请求，通过fork() 一个子进程去处理客户端请求，主进程则继续阻塞接收客户端请求。然后服务端找到对应文件通过fopen 打开后读取内容传输到客户端。

## 三、实验结果与分析

### 3.1 编译
![在这里插入图片描述](https://img-blog.csdnimg.cn/53f55f761cad4132910cd4fe32253fe0.png)

 ### 3.2 运行服务端
![在这里插入图片描述](https://img-blog.csdnimg.cn/3a23cb659fb740b3852063e87b23a20f.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/85bb6b16e8a64bd6aca9720e19cfc1ab.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/1ff7fda7f08d41ffa68a3e0ab2456037.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/a4a627b972db4130976d88a42578e518.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/ddfb6a749ad743229538c02aef6bd02f.png)

 ### 3.3 运行客户端
![在这里插入图片描述](https://img-blog.csdnimg.cn/5f9962b693b84e1e83e6cc611026f404.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/73f5c567416b4062918dbc156c14a0b7.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/3a35294d49324063bf95170892d9cda1.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/a57d48e089444c44a1797769bb97fab9.png)
### 3.4 结果分析
本次实验完成了，基于网络编程的客户端服务器程序，实现了查询远程文件目录列表、文件下载等功能。同时对网络编程模型进行了优化，通过 fork() 子进程的方式实现了多客户端并发访问服务器的目标。但是仍然存在一定问题，内核为每一个访问的客户端分配一个进程阻塞进行处理，如果客户端出现异常长时间不响应，服务端进程也会一直阻塞，这样就造成了资源的浪费。可以采用 select/poll/epoll 模型进行优化，它们能够基于具体事件(比如读事件、写事件)来分配进程进行处理，没有事件时就让当前进程去做其它事情，这样避免了资源的空耗。
